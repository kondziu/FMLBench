function chunky_array(chunk_size, initializer) -> 
object begin
    let chunk_size = chunk_size /*int*/;
    let values = array(chunk_size, initializer);
    let initializer = initializer;
    let next_chunk = null /*null|chunky_array*/;

    function get(index /*int*/) -> 
    begin
        if this.chunk_size <= index
        then this.get_from_next_chunk(index)
        else this.values[index];
    end;

    function get_from_next_chunk(index /*int*/) ->
    begin 
        if null == this.next_chunk
        then this.initializer
        else this.next_chunk[index - this.chunk_size];        
    end;

    function set(index /*int*/, value) -> 
    begin
        if this.chunk_size <= index
        then this.set_in_next_chunk(index, value)
        else this.values[index] <- value;
    end;

    function set_in_next_chunk(index /*int*/, value) ->
    begin 
        if null == this.next_chunk
        then this.next_chunk <- chunky_array(this.chunk_size, this.initializer);

        this.next_chunk[index - this.chunk_size] <- value;
    end;

    function count(needle) -> /*int*/
    begin
        if needle == this.initializer 
        then print("Warning! Counting values ~ which are used to populate empty elements.\n",  
                   this.initializer);

        let counter = 
            object begin 
                let needle = needle;
                let count = 0;
                function apply(index, value) -> 
                    if this.needle == value
                    then begin 
                        this.count <- this.count + 1;
                        true
                    end
                    else false
            end;

        this.for_each(counter);
        counter.count;
    end;        

    function find(needle) -> /*int*/
    begin
        if needle == this.initializer 
        then print("Warning! Looking for value ~ which is used to populate empty elements.\n",
                   this.initializer);

        let finder = 
            object begin 
                let needle = needle;
                let found_index = null;
                function apply(index, value) -> 
                    if this.needle == value
                    then begin 
                        this.found_index <- index;
                        true
                    end
                    else false
            end;

        this.find_by_condition(finder);
        finder.found_index;
    end;

    function find_by_condition(lambda /*object with apply(index, value) -> boolean*/) -> /*int*/
        this.find_by_condition_with_offset(0, lambda);

    function find_by_condition_with_offset(index_offset /*int*/, 
                                           lambda /*object with apply(index, value) -> boolean*/) -> /*int*/
    begin
        let i = 0;
        let continue = true;
        let found = false;

        while continue
        do begin       
            found <- lambda.apply(index_offset + i, this.values[i]);
            if found 
            then continue <- false
            else if i < this.chunk_size - 1
            then i <- i + 1 
            else continue <- false;
        end;  

        if false == found & null != this.next_chunk
        then this.next_chunk.find_by_condition_with_offset(index_offset + this.chunk_size, lambda);
    end;

    function for_each(lambda /*object with apply(index, value)*/) -> 
        this.for_each_with_offset(0, lambda);    

    function for_each_with_offset(index_offset /*int*/, lambda /*object with apply(index, value)*/) -> 
    begin
        let i = 0;
        while i < this.chunk_size
        do begin
            lambda.apply(index_offset + i, this.values[i]);
            i <- i + 1;
        end;  

        if null != this.next_chunk
        then this.next_chunk.for_each_with_offset(index_offset + this.chunk_size, lambda);
    end;

    function print_all() -> 
        this.for_each(object begin function apply(i, v) -> print("~: ~\n", i, v); end);
end;

// let arr = chunky_array(100, null);
// print("~\n", arr[0]);
// print("~\n", arr[99]);
// print("~\n", arr[100]);
// print("~\n", arr[101]);
// print("~\n", arr[105]);

// arr[0] <- false;
// arr[5] <- 42;
// arr[10] <- false;
// arr[99] <- false;
// arr[100] <- 100;
// arr[101] <- 101;
// arr[105] <- false;

// print("~\n", arr[0]);
// print("~\n", arr[99]);
// print("~\n", arr[100]);
// print("~\n", arr[101]);
// print("~\n", arr[105]);

// arr.print_all();

// print("42 at ~\n", arr.find(42));
// print("101 at ~\n", arr.find(101));
// print("false at ~\n", arr.find(false));
// print("nulls ~\n", arr.count(null));
// print("falses ~\n", arr.count(false));
// print("101s ~\n", arr.count(101));

// function chunky_list(chunk_size, initializer) ->
// object extends chunky_array(chunky_array, initializer) ->
// begin
//     let last_element = 0;
//     function push(value) -> 
//     begin
//         this.set[last_element] <- 
//         this.last_element <- value;

//     end;
// end;

function chunky_map(chunk_size, initializer) -> 
object begin
    let keys = chunky_array(chunk_size, null);
    let values = chunky_array(chunk_size, initializer);
    let next_entry = 0;

    function get(key /*any with == and not null*/) -> 
    begin
        if key == null
        then print("Warning! Looking for null, but keys cannot be null.\n");

        let index /*int|null*/ = this.keys.find(key);
        if null == index 
        then this.values.initializer 
        else this.values[index];
    end;

    function set(key /*any with == and not null*/, value) -> 
    begin
        if key == null
        then print("Warning! Looking for null, but keys cannot be null.\n");

        let index /*int|null*/ = this.keys.find(key);
        if null == index
        then begin
           this.keys[this.next_entry] <- key;
           let result = this.values[this.next_entry] <- value; 
           this.next_entry <- this.next_entry + 1;
           result
        end
        else begin
            this.values[index] <- value;
        end;
    end;

    function print_all() -> 
    begin
        let printer = 
            object begin 
                let map = this;
                function apply(i, key) -> 
                    if i < this.map.next_entry 
                    then print("~: ~\n", key, this.map.values[i]); 
            end;

        this.keys.for_each(printer);
    end;
end;

// let map = chunky_map(100, 0);

// map.print_all();
// print("\n");

// print("map[1]: ~\n", map[1]);
// print("map[2]: ~\n", map[2]);
// print("map[101]: ~\n", map[101]);
// print("\n");

// map.print_all();
// print("\n");

// print("map[1] <- 1 : ~\n", map[1] <- 1);
// print("map[2] <- 22 : ~\n", map[2] <- 22);
// print("map[101] <- 101 : ~\n", map[101] <- 101);
// print("map[101] <- 103 : ~\n", map[101] <- 103);
// print("map[5] <- 55555 : ~\n", map[5] <- 55555);
// print("\n");

// map.print_all();
// print("\n");

// print("map[1]: ~\n", map[1]);
// print("map[2]: ~\n", map[2]);
// print("map[101]: ~\n", map[101]);
// print("map[5]: ~\n", map[5]);
// print("map[6]: ~\n", map[6]);
// print("\n");

let WHITE = object
begin
    let black = false;
    function flip() -> BLACK;
    function is_black() -> false;
    function is_white() -> true;
    function draw() -> print(".");
end;

let BLACK = object
begin
    let black = true;
    function flip() -> WHITE;
    function is_black() -> true;
    function is_white() -> false;
    function draw() -> print("#");
end;

//              ^x
// CCW          |5       CW
//   +----      |    ----+
//   |          |3       |
//   v          |        v
//              |
// <------------+------------>
//  -5 -3       |       3  5
//              |
//              |-3
//              |
//              |-5
//              v

let UP = object 
begin
    let x = 0; let y = 1;
    function turn_clockwise() -> RIGHT;
    function turn_counter_clockwise() -> LEFT;
    function draw() -> print("^");
end;  

let DOWN = object 
begin
    let x = 0; let y = -1;
    function turn_clockwise() -> LEFT;
    function turn_counter_clockwise() -> RIGHT;
    function draw() -> print("v");
end;

let LEFT = object 
begin
    let x = -1; let y = 0;
    function turn_clockwise() -> UP;
    function turn_counter_clockwise() -> DOWN;
    function draw() -> print("<");
end;

let RIGHT = object 
begin
    let x = 1; let y = 0;
    function turn_clockwise() -> DOWN;
    function turn_counter_clockwise() -> UP;
    function draw() -> print(">");
end;

function coordinates(x /*int*/, y /*int*/) -> 
object begin
    let x = x; let y = y;

    function move_in_direction(direction /*UP|DOWN|LEFT|RIGHT*/) -> 
        coordinates(this.x + direction.x, this.y + direction.y);

    function ==(other) -> 
        if other == null 
        then false
        else this.y == other.y & this.x == other.x;

    function !=(other) -> 
        if other == null 
        then true
        else this.y != other.y & this.x != other.x;
end;

function ant(initial_position /*coordinates*/, 
             initial_direction /*UP|DOWN|LEFT|RIGHT*/) ->
object begin
    let direction = initial_direction;
    let position = initial_position;
    function step(color /*BLACK|WHITE*/) -> 
    begin
        this.direction <- 
            if color.is_black() then this.direction.turn_counter_clockwise()
            else if color.is_white() then this.direction.turn_clockwise()
            else print("Error: Unknown color: ~. Should be ~ or ~.", color, BLACK, WHITE);
        this.position <- this.position.move_in_direction(this.direction);
        color.flip();
    end;

    function draw() -> this.direction.draw();
end;

let game = 
    object begin
        let ant = ant(coordinates(0,0), UP);
        let world = chunky_map(100, WHITE);
        function move() -> 
            this.world[this.ant.position] <- 
                this.ant.step(this.world[this.ant.position]); 

        function draw() -> 
        begin           
            //print("ant position ~\n", this.ant.position);

            let boundary_finder = object
            begin
                let min_x = this.ant.position.x; let min_y = this.ant.position.y;
                let max_x = this.ant.position.x; let max_y = this.ant.position.y;

                function apply(_, coordinates /*coordinates*/) -> 
                begin
                    if coordinates != null 
                    then begin
                        if coordinates.x < this.min_x then this.min_x <- coordinates.x;
                        if coordinates.x > this.max_x then this.max_x <- coordinates.x;
                        if coordinates.y < this.min_y then this.min_y <- coordinates.y;
                        if coordinates.y > this.max_y then this.max_y <- coordinates.y;
                    end;
                end;
            end;

            this.world.keys.for_each(boundary_finder);
            //print("boundary finder ~\n", boundary_finder);
            
            let y = boundary_finder.max_y;
            while y >= boundary_finder.min_y
            do begin
                let x = boundary_finder.min_x;
                while x <= boundary_finder.max_x                
                do begin
                    let position = coordinates(x, y);                    
                    //print("[~ ~]", position.x, position.y);
                    if position == this.ant.position 
                    then this.ant.draw()
                    else this.world[position].draw();                    
                    x <- x + 1;
                end;
                print("\n");
                y <- y - 1;
            end;
            print("\n");
        end;
    end;

begin 
    let turn = 0;    
    while turn <= 200
    do begin 
        print("turn ~\n", turn);
        game.move();
        game.draw();
        turn <- turn + 1;
    end;
end;